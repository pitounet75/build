diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index 0049603f3294..0789f61be489 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -1309,21 +1309,6 @@ bool __init early_init_dt_scan(void *params)
 	return true;
 }
 
-static void *__init copy_device_tree(void *fdt)
-{
-	int size;
-	void *dt;
-
-	size = fdt_totalsize(fdt);
-	dt = early_init_dt_alloc_memory_arch(size,
-					     roundup_pow_of_two(FDT_V17_SIZE));
-
-	if (dt)
-		memcpy(dt, fdt, size);
-
-	return dt;
-}
-
 /**
  * unflatten_device_tree - create tree of device_nodes from flat blob
  *
@@ -1334,29 +1319,7 @@ static void *__init copy_device_tree(void *fdt)
  */
 void __init unflatten_device_tree(void)
 {
-	void *fdt = initial_boot_params;
-
-	/* Don't use the bootloader provided DTB if ACPI is enabled */
-	if (!acpi_disabled)
-		fdt = NULL;
-
-	/*
-	 * Populate an empty root node when ACPI is enabled or bootloader
-	 * doesn't provide one.
-	 */
-	if (!fdt) {
-		fdt = (void *) __dtb_empty_root_begin;
-		/* fdt_totalsize() will be used for copy size */
-		if (fdt_totalsize(fdt) >
-		    __dtb_empty_root_end - __dtb_empty_root_begin) {
-			pr_err("invalid size in dtb_empty_root\n");
-			return;
-		}
-		of_fdt_crc32 = crc32_be(~0, fdt, fdt_totalsize(fdt));
-		fdt = copy_device_tree(fdt);
-	}
-
-	__unflatten_device_tree(fdt, NULL, &of_root,
+	__unflatten_device_tree(initial_boot_params, NULL, &of_root,
 				early_init_dt_alloc_memory_arch, false);
 
 	/* Get pointer to "/chosen" and "/aliases" nodes for use everywhere */
@@ -1378,9 +1341,22 @@ void __init unflatten_device_tree(void)
  */
 void __init unflatten_and_copy_device_tree(void)
 {
-	if (initial_boot_params)
-		initial_boot_params = copy_device_tree(initial_boot_params);
+	int size;
+	void *dt;
 
+	if (!initial_boot_params) {
+		pr_warn("No valid device tree found, continuing without\n");
+		return;
+	}
+
+	size = fdt_totalsize(initial_boot_params);
+	dt = early_init_dt_alloc_memory_arch(size,
+					     roundup_pow_of_two(FDT_V17_SIZE));
+
+	if (dt) {
+		memcpy(dt, initial_boot_params, size);
+		initial_boot_params = dt;
+	}
 	unflatten_device_tree();
 }
 
diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h
index 485483524b7f..1906bbdff32b 100644
--- a/drivers/of/of_private.h
+++ b/drivers/of/of_private.h
@@ -175,9 +175,10 @@ static inline struct device_node *__of_get_dma_parent(const struct device_node *
 }
 #endif
 
-int fdt_scan_reserved_mem(void);
 void fdt_init_reserved_mem(void);
-
-bool of_fdt_device_is_available(const void *blob, unsigned long node);
+void fdt_reserved_mem_save_node(unsigned long node, const char *uname,
+			       phys_addr_t base, phys_addr_t size);
+static bool of_fdt_device_is_available(const void *blob, unsigned long node);
+static int fdt_scan_reserved_mem(void);
 
 #endif /* _LINUX_OF_PRIVATE_H */
diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 8236ecae2953..d6fc85d5f5ac 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -59,7 +59,7 @@ static int __init early_init_dt_alloc_reserved_memory_arch(phys_addr_t size,
 /*
  * fdt_reserved_mem_save_node() - save fdt node for second pass initialization
  */
-static void __init fdt_reserved_mem_save_node(unsigned long node, const char *uname,
+void __init fdt_reserved_mem_save_node(unsigned long node, const char *uname,
 					      phys_addr_t base, phys_addr_t size)
 {
 	struct reserved_mem *rmem = &reserved_mem[reserved_mem_count];
